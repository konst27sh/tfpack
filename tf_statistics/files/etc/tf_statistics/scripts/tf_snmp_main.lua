#!/usr/bin/lua

---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by sheverdin.
--- DateTime: 4/26/24 4:11 PM
---
---
package.path = "/etc/tf_statistics/scripts/?.lua;" .. package.path

local b_m_6  = require "snmp_base_main_6"
local b_m     = require "snmp_base_main"
local b_m_get = require "snmp_base_get"

local requestType = ""
local inputOid    = arg[2]

local next_oid = ""
local base_length = 7
local psw_type_index = 10
local oid_arr = {}

local config_require = {
    nil,
    { "snmp_config_ar" },
    { "snmp_config_poe" },
    { "snmp_config_outState" }
}

local status_require = {
    nil,
    { "snmp_status_sensor" },
    nil,
    nil,
    { "snmp_status_poe" },
    { "snmp_status_ar", "" },
    { "snmp_status_sfp" },
}

local psw_enum = {
    config_require,
    status_require
}

local shtEnum =
{
    ["0"] = "2",
    ["1"] = "1",
}

local alarmEnum =
{
    ["short"]   = "1",
    ["open"]    = "2",
    ["any"]     = "3",
}

local function send_Get_result(oid, mibObj, res)
    if mibObj ~= nil then
        print(oid)
        if (mibObj.valueType == "DisplayString") then
            print("String")
            res = string.gsub(res, "%s+$", "")
            print(res)
        else
            print(mibObj.valueType)
            print(res)
        end
    else
        print("1.3.6.1.4.1.8072.3.2.10")
        print("OID")
        print("1.3.6.1.4.1.8072.3.2.10")
    end
end

local function get_bStruct(psw_index, index)
    if psw_enum[psw_index] == nil then
        return "not_found"
    end
    local psw_type = psw_enum[psw_index]
    if psw_type[index] == nil then
        return "not_found"
    end

    local psw_require = psw_type[index]
    local category_index = 1
    return psw_require
end

local function get_oidArr(oid)
    local arr = {}
    local in_endIndex = string.len(oid)
    oid = string.sub(oid, 1, in_endIndex)
    for num in oid:gmatch("%d+") do
        table.insert(arr, tonumber(num))
    end
    return arr
end

-- ---------------------------------------------
-- end_time = socket.gettime()
-- elapsed_time = (end_time - start_time)
-- print("elapsed_time 3 = " .. elapsed_time)
-- ---------------------------------------------

local function snmp_main_getNext_handler()
    local status = ""
    local mibObj = {}
    local res = ""
    local jumpToNext = 0
    local break_count = 0
    local category_index = 1
    while status ~= "OK" do
        break_count = break_count + 1
        if break_count > 10 then
            return "critical error"
        end
        oid_arr = get_oidArr(inputOid)
        next_oid = inputOid
        local oid_length = #oid_arr - base_length
        if oid_length <= 4 then
            local base_list = b_m.main[oid_length + 1]
            if base_list[inputOid] ~= nil then
                mibObj = base_list[inputOid]
                next_oid = mibObj.next_oid
                oid_arr = get_oidArr(next_oid)
                oid_length = #oid_arr - base_length
                jumpToNext = jumpToNext + 1
                inputOid = next_oid
            else
                return "not_found"
            end
        end
        if oid_length == 5 then
            local base_list = b_m_6.main[oid_length]
            if base_list[inputOid] ~= nil then
                mibObj = base_list[inputOid]
                if jumpToNext == 0 then
                    next_oid = mibObj.next_oid
                    inputOid = next_oid
                    jumpToNext = jumpToNext + 1
                else
                    res, status = mibObj.ubusType(mibObj, 0)
                end
            else
                return "not_found"
            end
        end
        if oid_length >= 7 then
            local value_index = 0
            local next_value_index = 0
            local max_oid_length = 0
            jumpToNext = jumpToNext + 1
            local psw_index = oid_arr[psw_type_index]
            local index = oid_arr[psw_type_index + 1]
            local psw_require = get_bStruct(psw_index, index)
            if #psw_require == 1 then
                category_index = 1
                max_oid_length = 7
            elseif #psw_require > 1 then
                category_index = oid_arr[psw_type_index + 2]
                max_oid_length = 8
            end
            local b_typed = require(psw_require[category_index])
            if oid_length == max_oid_length then
                value_index = 1
                inputOid = next_oid
                mibObj = b_typed.main[inputOid]
                if b_typed.main[inputOid] == nil then
                    print("b_typed.main not found")
                    return "not_found"
                end
                next_oid = next_oid .. "." .. value_index
                res, status = mibObj.ubusType(mibObj, value_index)
            elseif oid_length == max_oid_length + 1 then
                value_index = oid_arr[#oid_arr]
                next_value_index = tostring(tonumber(value_index) + 1)
                inputOid = oid_arr[1]
                for i = 2, max_oid_length + base_length do
                    inputOid = inputOid .. "." .. oid_arr[i]
                end
                if b_typed.main[inputOid] == nil then
                    print("not found max_oid_length + 1 ")
                    return "not_found"
                end
                mibObj = b_typed.main[inputOid]
                if mibObj.nodetype == "column" then
                    res, status = mibObj.ubusType(mibObj, next_value_index)
                    if status == "OK" then
                        next_oid = inputOid .. "." .. next_value_index
                    elseif status == "over_index" then
                        next_oid = mibObj.next_oid
                        inputOid = next_oid
                    end
                end
            end
        end
    end
    send_Get_result(next_oid, mibObj, res)
    return "OK"
end

local function snmp_main_get_handler()
    local res, status = ""
    local mibObj  = {}
    oid_arr = get_oidArr(inputOid)
    local value_index = oid_arr[#oid_arr]
    local oid_length = #oid_arr - base_length
    local temp_inputOid = inputOid
    if oid_length == 6 then
        if value_index == 0 then
            temp_inputOid = oid_arr[1]
            for i = 2, 5 + base_length do
                temp_inputOid = temp_inputOid .. "." .. oid_arr[i]
            end
            oid_arr = get_oidArr(temp_inputOid)
            oid_length = #oid_arr - base_length
        end
    end

    if oid_length == 5 then
        mibObj = b_m_get.main[temp_inputOid]
        if mibObj == nil then
            return "not_found"
        end
        res, status = mibObj.ubusType(mibObj, 0)
    elseif oid_length == 8 then
        value_index = oid_arr[#oid_arr]
        temp_inputOid = oid_arr[1]
        for i = 2, 7 + base_length do
            temp_inputOid = temp_inputOid .. "." .. oid_arr[i]
        end
        if b_m_get.main[temp_inputOid] == nil then
            return "not_found"
        end
        mibObj = b_m_get.main[temp_inputOid]
        if mibObj.nodetype == "column" then
            res, status = mibObj.ubusType(mibObj, value_index)
        end
    end
    send_Get_result(inputOid, mibObj, res)
    return "OK"
end

local function snmp_main_set_handler()

end

local requestType_enum = {
    ["-g"] = snmp_main_get_handler,
    ["-n"] = snmp_main_getNext_handler,
    ["-s"] = snmp_main_set_handler
}

local function tf_run_snmp()
    local arg_1 = arg[1]
    if requestType_enum[arg_1] == nil then
        print("error: requestType not valid")
        return "requestType_not_valid"
    end

    if string.sub(inputOid, 1, 1) == "." then
        inputOid = string.sub(inputOid, 2, string.len(inputOid))
    end
    requestType = requestType_enum[arg_1]
    if arg[2] ~= nil then
        local snmp_res = requestType()
        if snmp_res ~= "OK" then
            send_Get_result("", nil, 0)
        end
    else
        print("OID must be presented arg[2]")
    end
end

tf_run_snmp()
