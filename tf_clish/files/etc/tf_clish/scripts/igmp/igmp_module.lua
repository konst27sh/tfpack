---
--- Generated by Luanalysis
--- Created by sheverdin.
--- DateTime: 2/16/24 4:51 PM
---

local igmp_module = {}

local limitValue = {
    min_table_size                    = 1,
    max_table_size                    = 1024,
    min_query_interval_sec          = 30,
    max_query_interval_sec          = 600,
    min_query_response_interval_sec  = 1,
    max_query_response_interval_sec  = 25,
    min_robustness_count              = 2,
    max_robustness_count              = 255,
    min_last_member_interval_sec      = 1,
    max_last_member_interval_sec      = 25,
}

local igmp_config_json = {}

local igmp_state_str2Digit = {
    ["disable"] = "0",
    ["enable"]  = "1"
}

igmp_module.igmp_state_digir2str = {
    ["0"] = "disable",
    ["1"] = "enable"
}

local canti_sec = 100
local querier_interval = "no"
local querier_interval_value = ""
local global_value = 0

local function igmp_state(option)
    local error = 1
    local stateValue = tonumber(option.value)
    if type(stateValue) ~= "number" then
        print("error: IGMP state - value not corrected")
        return error
    end
    error = 0
    global_value = stateValue
    return error
end

local function igmp_max_snooping_table_size(option)
    local error = 1
    local table_size = tonumber(option.value)
    if type(table_size) ~= "number" then
        print("error: Snooping Table size - value not corrected")
        return error
    end

    if table_size < limitValue.min_table_size or table_size > limitValue.max_table_size then
        print("error: Max Snooping table size must be in range 1 - 1024")
    else
        global_value = table_size
        error = 0
    end
    return error
end

local function igmp_multicast_querier(option)
    local stateValue = tonumber(option.value)
    if type(stateValue) ~= "number" then
        print("error: Multicast Querier - value not corrected")
        return error
    end
    global_value = stateValue
    return 0
end

local function igmp_robustness(option)
    local error = 1
    local robustness_count = tonumber(option.value)
    if type(robustness_count) ~= "number" then
        print("error: " .. option .. " - value not corrected")
        return error
    end

    if robustness_count < limitValue.min_robustness_count or robustness_count > limitValue.max_robustness_count then
        print("error: Robustness count must be in range 2 - 255")
    else
        global_value = robustness_count
        error = 0
    end

    return error
end

local function igmp_query_interval(option)
    local error = 1
    local queryInterval_sec = tonumber(option.value)
    if type(queryInterval_sec) ~= "number" then
        print("error: Query Interval - value not corrected")
        return error
    end

    if queryInterval_sec < limitValue.min_query_interval_sec or queryInterval_sec > limitValue.max_query_interval_sec then
        print("error: Query Interval must be in range 30 - 600 sec")
    else
        global_value = queryInterval_sec * canti_sec
        error = 0
    end
    return error
end

local function igmp_query_response_interval(option)
    local error = 1
    local responseIntervalValue = tonumber(option.value)
    if type(responseIntervalValue) ~= "number" then
        print("error: Query Response Interval - value not corrected")
        return error
    end

    if responseIntervalValue < limitValue.min_query_response_interval_sec or responseIntervalValue > limitValue.max_query_response_interval_sec then
        print("error: Query Response Interval must be in range 1 - 25 sec")
        return error
    end

    if querier_interval == "no" then
        local query_response_struct = igmp_module.cmd_global["query_interval"]
        local query_option = query_response_struct["option"]
        if igmp_config_json[query_option] == nil then
            print("error: Query Response Interval must be set after Query Interval")
            return error
        end
    end
    global_value = responseIntervalValue * canti_sec
    error = 0
    return error
end

local function igmp_last_member_interval(option)
    local error = 1
    local lastMemberInterval = tonumber(option.value)
    if type(lastMemberInterval) ~= "number" then
        print("error: Last Member Interval - value not corrected")
        return error
    end

    if lastMemberInterval < limitValue.min_last_member_interval_sec or lastMemberInterval > limitValue.max_last_member_interval_sec then
        print("error: Last Member Interval must be in range 1 - 25 sec")
        return error
    else
        global_value = lastMemberInterval * canti_sec
        error = 0
    end
    return error
end

function igmp_module.igmp_setGlobalConfig(tf, commandList)
    local commandList_lentgth = #commandList
    local ubus_cmd = "ubus call uci get '{\"config\":\"network\", \"type\":\"device\", \"section\":\"switch\"}'"
    igmp_config_json = tf.collectJsonTable(ubus_cmd)
    if igmp_config_json ~= nil and igmp_config_json["values"] ~= nil then
        igmp_config_json = igmp_config_json["values"]
        local ubus_set_igmp = "ubus call uci set '{\"config\":\"network\", \"section\":\"switch\", \"values\":{"
        local values_str = ""
        if commandList["query_response_interval"] ~= nil then
            if commandList["query_interval"] ~= nil then
                querier_interval = "yes"
                querier_interval_value = commandList["query_interval"]
            end
        end
        for l, option in pairs(commandList) do
            local config_struct = igmp_module.cmd_global[option.arg]
            local error = config_struct.func(option)
            local v_option = config_struct.option
            local v_value = ""
            if igmp_state_str2Digit[option.value] ~= nil then
                v_value = igmp_state_str2Digit[option.value]
            else
                v_value = option.value
            end
            if error == 0 then
                if l ~= 1 and l <= #commandList then
                    values_str = values_str .. ", "
                end
                values_str = values_str .. "\"" .. v_option .. "\":\"" .. global_value .. "\""
            else
                commandList_lentgth = commandList_lentgth - 1
            end
        end

        if values_str == "" then
            print("info: no parameters to set")
            return
        end
        values_str = values_str .. "}}'"
        ubus_set_igmp = ubus_set_igmp .. values_str
        tf.executeCommand(ubus_set_igmp)
    end
end

function igmp_module.igmp_setPortConfig(tf, commandList, i)
    local ubus_cmd = "ubus call uci get '{\"config\":\"network\", \"type\":\"device\"}'"
    igmp_config_json = tf.collectJsonTable(ubus_cmd)
    if igmp_config_json ~= nil and igmp_config_json["values"] ~= nil then
        igmp_config_json = igmp_config_json["values"]

        for _, struct in pairs(igmp_config_json) do
            if struct["name"] ~= nil then
                if struct["name"] == "lan" .. i then
                    local section = struct[".name"]
                    local ubus_set_igmp = "ubus call uci set '{\"config\":\"network\", \"section\":\"" .. section .. "\", \"values\":{"
                    local values_str = ""
                    for l, option in pairs(commandList) do
                        local portConfig = igmp_module.cmd_ports[option.arg]
                        local v_option = portConfig.option
                        local v_value = option.value
                        if l ~= 1 and l <= #commandList then
                            values_str = values_str .. ", "
                        end
                        values_str = values_str .. "\"" .. v_option .. "\":\"" .. v_value .. "\""
                    end
                    values_str = values_str .. "}}'"
                    ubus_set_igmp = ubus_set_igmp .. values_str
                    tf.executeCommand(ubus_set_igmp)
                end
            end
        end
    else
        print("error: igmp config is wrong")
    end
end

igmp_module.cmd_global = {
    ["state"]                   = { option = "igmp_snooping",           str = "\tState:                   \t", func = igmp_state },
    ["max_snooping_table_size"] = { option = "hash_max",                str = "\tMax_snooping_table_size: \t", func = igmp_max_snooping_table_size },
    ["multicast_querier"]       = { option = "multicast_querier",       str = "\tMulticast querier:       \t", func = igmp_multicast_querier },
    ["robustness"]              = { option = "robustness",              str = "\tRobustness:              \t", func = igmp_robustness },
    ["query_interval"]          = { option = "query_interval",          str = "\tQuery interval:          \t", func = igmp_query_interval },
    ["query_response_interval"] = { option = "query_response_interval", str = "\tQuery response interval: \t", func = igmp_query_response_interval },
    ["last_member_interval"]    = { option = "last_member_interval",    str = "\tLast member interval:    \t", func = igmp_last_member_interval },
}

igmp_module.cmd_ports = {
    ["state"]                = { option = "multicast",                          str = "\tmulticast:                         \t", func = igmp_setportConfig },
    ["drop_v4"]              = { option = "drop_v4_unicast_in_l2_multicast",    str = "\tdrop v4 unicast in l2 multicast:   \t", func = igmp_setportConfig },
    ["unicast_flood"]        = { option = "unicast_flood",                      str = "\tunicast flood:                     \t", func = igmp_setportConfig },
    ["multicast_router"]     = { option = "multicast_router",                   str = "\tmulticast router:                  \t", func = igmp_setportConfig },
    ["multicast_to_unicast"] = { option = "multicast_to_unicast",               str = "\tmulticast to unicast:              \t", func = igmp_setportConfig },
    ["fast_leave"]           = { option = "multicast_fast_leave",               str = "\tmulticast fast leave:              \t", func = igmp_setportConfig },
}

function igmp_module.getRawJsonData(igmpStatus)
    local json_data         = {}
    local current_interface = ""
    local current_id        = 0

    local ctrl = {
        maxCol = 5,
        interfaceNum = 0
    }

    for line in igmpStatus:gmatch("[^\n]+") do
        local cols = {}
        for col in line:gmatch("%S+") do
            table.insert(cols, col)
        end
        if #cols == ctrl.maxCol then
            local interface = "\"" .. cols[2] .. "\" :"
            if interface ~= current_interface then

                ctrl.interfaceNum = ctrl.interfaceNum + 1
                json_data[interface] = {}
                current_interface = interface
                current_id = 0
            end

            current_id = current_id + 1
            json_data[interface][current_id] = {
                id              = tostring(current_id),
                if_index        = cols[1],
                label           = cols[3],
                number_of_ref   = cols[4],
                bound_addr      = cols[5]
            }
        end
    end
    return json_data, ctrl
end

function igmp_module.convertTableToJson(json_data, ctrl)
    local json_output = "{\n \"mcast\": {\n\"interfaces\": {\n"
    local count_1 = 0
    local count_2 = 0
    local count_3 = 0

    for interface, data in pairs(json_data) do
        count_1 = count_1 + 1

        json_output = json_output .. " " .. interface .. " [\n"
        count_2 = 0
        for _, values in pairs(data) do
            count_2 = count_2 + 1
            count_3 = 0
            if count_2 == 1 then
                json_output = json_output .. "\t{\n"
            elseif count_2 > 1 then
                json_output = json_output .. "\t{\n"
            end
            for key, value in pairs(values) do
                count_3 = count_3 + 1
                if count_3 < ctrl.maxCol then
                    json_output = json_output .. ' \t\t\"' .. key .. '":"' .. value .. '",\n'
                elseif count_3 == ctrl.maxCol then
                    json_output = json_output .. ' \t\t\"' .. key .. '":"' .. value .. '"\n'
                end
            end

            if count_2 < #data then
                json_output = json_output .. "\t},\n"
            elseif count_2 == #data then
                json_output = json_output .. "\t}\n"
            end
        end

        if count_1 < ctrl.interfaceNum then
            json_output = json_output .. "],\n"
        elseif count_1 == ctrl.interfaceNum then
            json_output = json_output .. "]\n"
        end
    end
    json_output = json_output .. "}\n}\n}"
    return json_output
end

return igmp_module
