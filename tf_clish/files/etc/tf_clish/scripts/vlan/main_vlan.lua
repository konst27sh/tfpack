#!/usr/bin/lua

---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by sheverdin.
--- DateTime: 6/17/24 12:43 PM
---
---
package.path = "/etc/tf_clish/scripts/vlan/?.lua;" .. package.path

local tf   = require "tf_module"
local vlan = require "vlan_module"
local pm   = require "print_module"
local br   = require "bridge_module"

local vlanRange_in     = ""
local cmd_in           = ""
local taggedType_in    = ""
local portList_in      = ""
local device_in        = "switch"

local if_deleted_list = {}

local portRange = {}
local vlanRange = {}

local function add_tagged(vlanArr, cmd)
    local res_add = vlan.add_tagged(vlanArr, vlanRange, portRange, cmd)
    return res_add
end

local function add_untagget(vlanArr, cmd)
    if vlanRange[3] == "range" then
        print("error: for this operation choose only one Vlan id")
    else
        local res_addU = vlan.add_untagged(vlanArr, vlanRange[1], portRange, cmd)
        return res_addU
    end
end

local function add_not_memb(vlanArr, _)
    local res_notMember = vlan.add_notMemberPorts(vlanArr, vlanRange, portRange)
    return res_notMember
end

local cmdAdd_List =
{
    tagged     = { cmd = "tagged",      func = add_tagged },
    untagged   = { cmd = "untagged",    func = add_untagget },
    not_memb   = { cmd = "mot_member",  func = add_not_memb },
}

local function vlan_add(vlanArr, _)
    local cmdList = cmdAdd_List[taggedType_in]
    local res_vlan_add = cmdList.func(vlanArr, "add")
    return res_vlan_add
end

local function vlan_edit(vlanArr, _)
    --print("taggedType_in = " .. taggedType_in)
    local cmdList = cmdAdd_List[taggedType_in]
    local res_vlan_edit = cmdList.func(vlanArr, "edit")
    return res_vlan_edit
end

local function vlan_delete(vlanArr)
    for vlan_num, vlan_list in pairs(vlanArr) do
        local index = tonumber(vlan_num)
        local vlanRangeMin = tonumber(vlanRange[1])
        local vlanRangeMax = tonumber(vlanRange[2])
        if index >= vlanRangeMin and index <= vlanRangeMax then
            if vlan_list.mngtVlan == nil then
                print(pm.warning.vlan_delete_1)
                print(pm.warning.vlan_delete_2)
                vlan.delete(vlan_list.id)
            else
                if vlan_list.mngtVlan == "yes" then
                    print(pm.warning.vlan_delete_3 .. "vlan id: *\"" .. index .. "\"*")
                    if type(vlan_list.ifname) == "table" then
                        print("\t\tinterface ")
                        for _, ifname in pairs(vlan_list.ifname) do
                            print("\t\t\t*" .. ifname .. "* based on VLAN *" .. index .. "*")
                        end
                    else
                        print("\t\tinterface *" .. vlan_list.ifname .. "* based on VLAN *" .. index .. "*")
                    end
                    return "error"
                end
            end
        end
    end
    return "vlan_ok"
end

local function vlan_param(vlanArr)
    for vlan_num, vlan_list in pairs(vlanArr) do
        local index = tonumber(vlan_num)
        local vlanRangeMin = tonumber(vlanRange[1])
        local vlanRangeMax = tonumber(vlanRange[2])
        local str = taggedType_in
        if cmd_in == "name" then
            cmd_in = "descr"
        end
        if index >= vlanRangeMin and index <= vlanRangeMax then
            vlan.set_param(vlan_list.id, cmd_in, str)
        end
    end
    return "vlan_ok"
end

local function vlan_mngt_vlan(vlanArr)
    local vlan_id = arg[1]
    local vlanList = {}
    local ifList, iflist_res = br.br_getIflist(vlan.cmd_vlan_list.cmd_netIfInfo)
    if iflist_res ~= 0 then
        print(pm.critical.if_list)
        return "error"
    end
    local status = "error"
    local ifName = taggedType_in

    for _, if_name in pairs(ifList) do
        if ifName == if_name then
            status = "OK"
            break
        end
    end

    if status == "OK" then
        if vlanArr[vlan_id] == nil then
            print("error: vlan *" .. vlan_id .. "* not presented")
            return "error"
        else
            vlanList = vlanArr[vlan_id]
            status = "OK"
        end
    end

    vlan.mngt_vlan(vlanList, vlan_id, ifName)
    return "vlan_ok"
end

local function vlan_show(vlanArr)
    local vlanId = arg[2]
    vlan.showVlanInfo(vlanArr, vlanId)
    return "vlan_ok"
end

local cmdVlanList =
{
    add       = { cmd = "add",       func = vlan_add },
    edit      = { cmd = "edit",      func = vlan_edit },
    delete    = { cmd = "delete",    func = vlan_delete },
    name      = { cmd = "name",      func = vlan_param },
    state     = { cmd = "state",     func = vlan_param },
    mngt_vlan = { cmd = "mngt_vlan", func = vlan_mngt_vlan },
    show      = { cmd = "show",      func = vlan_show },
}

local function getVlanArr()
    local netInfo = tf.collectJsonTable(vlan.cmd_vlan_list.cmd_netInfo)
    if netInfo == nil or netInfo["values"] == nil then
        print(pm.critical.config_is_wrong)
        return 1
    end
    netInfo = netInfo["values"]
    local vlanArr = vlan.getBridgeVlanList(netInfo)

    if (vlanArr == nil) then
        print(pm.critical.config_bridge_vlan)
        return 1
    end

    local ifList, res = br.br_getIflist(vlan.cmd_vlan_list.cmd_netIfInfo)
    if res ~= 0 then
        print(pm.critical.if_list)
    end

    for _, if_name in pairs(ifList) do
        local cmd = vlan.cmd_vlan_list.cmd_deviceInfo_1 .. if_name .. vlan.cmd_vlan_list.cmd_deviceInfo_2
        local marked = "no"
        vlanArr, marked = vlan.getMngmntVlan(cmd, vlanArr, if_name)
        if marked == "yes" then
            table.insert(if_deleted_list, if_name)
        end
    end
    if if_deleted_list == nil then
        print("deleted list is empty")
    elseif if_deleted_list ~= nil and #if_deleted_list > 0 then
        print("info: the system has not saved configuration")
        -- print("\t - For show changes  *changes show*")
        -- print("\t - For save configuration *changes save*")
        -- print("\t - For revert configuration *changes revert <config_type>*")
    end
    return vlanArr, 0
end

local function run_config_vlan()
    if arg[1] == "vlan_id" then
        vlanRange_in     = arg[2]
        cmd_in           = arg[3]
        taggedType_in    = arg[4]
        portList_in      = arg[5]
        if portList_in ~= nil and portList_in ~= "" then
            portRange = tf.checkPortRange(portList_in)
        end
        vlanRange = tf.checkPortRange(vlanRange_in)

        local vlanArr, res = getVlanArr()
        if res ~= 0 then
            print(pm.critical.regular .. " get vlan info")
            return 1
        end
        if cmd_in == "add" then
            if vlanRange[3] == "range" or vlanRange[3] == "once" then
                local vlanRangeMin = tonumber(vlanRange[1])
                local vlanRangeMax = tonumber(vlanRange[2])

                for i = vlanRangeMin, vlanRangeMax do
                    if vlanArr[tostring(i)] == nil then
                        res = vlan.uci_addVlan(tostring(i))
                    end
                end
            end
        end

        if res == "vlan_OK" then
            vlanArr = getVlanArr()
        end

        if cmd_in == "show" then
            if vlanRange ~= nil then
                local cmdList = cmdVlanList[cmd_in]
                cmdList.func(vlanArr)
            end
        else
            if taggedType_in ~= nil and taggedType_in ~= "" then
                if portRange ~= nil and vlanRange ~= nil then
                    local cmdList = cmdVlanList[cmd_in]
                    local res_main = cmdList.func(vlanArr)
                    if res_main ~= nil and res_main == "vlan_ok" then
                        print("info: vlan " .. vlanRange_in .. " " .. cmd_in .. " ports " .. portList_in .. " " .. taggedType_in .. " successfully!")
                    elseif res_main ~= nil and res_main == "not_found" then
                        print("warning: ports " .. portList_in .. " can not be *" .. cmd_in .. "*,  vlans " .. vlanRange_in)
                    else
                        print("warning: system error")
                    end
                end
            end
        end
    elseif arg[1] == "mngt_vlan" then
        if #arg[2] > 16 then
            print(pm.error.if_name_long)
            return 1
        end
        local vlanArr = getVlanArr()
        vlanRange_in = arg[3]
        vlanRange = tf.checkPortRange(vlanRange_in)
        if vlanRange[3] == "once" then
            local vlan_res = vlan.mngtVlan_handler(vlanArr, vlanRange[1], arg[2], arg[4], if_deleted_list)
            if vlan_res == 0 then
                print("info: VLAN configuration successfully")
            end
        else
            print("error: vlan id not corrected")
            return
        end
    end
end

run_config_vlan()

-- info: no ports assigned on Vlan *2*TODO check this message
