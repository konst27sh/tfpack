---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by sheverdin.
--- DateTime: 2/25/25 4:55 PM
---

package.path = "/etc/tf_clish/scripts/tools/?.lua;" .. package.path

local tf = require "tf_module"
local lfs = require "lfs"
local trf = require "transfer_file_module"
local bk = require "backup_module"

local restore_module = {}

local arg_enum = {
    "keep_setting",
    "auto",
    "remote_file",
    "host"
}

local function parsingArg()
    local arg_struct = {}
    local arg_table = {}
    for _, param in pairs(arg_enum) do
        for i = 2, #arg do
            if arg[i] == param then
                arg_struct[arg[i]] = arg[i + 1]
                break
            end
        end
        table.insert(arg_table, arg_struct)
    end
    return arg_struct
end

local function findStorageSize()
    local cmd_mtd = "cat /proc/mtd"
    local res_mtd = tf.executeCommand(cmd_mtd)

    local kern_size = 0
    local root_size = 0
    local whole_size = 0

    for line in res_mtd:gmatch("[^\n]+") do
        local parts = {}
        for part in line:gmatch("%S+") do
            table.insert(parts, part)
        end
        if parts then
            local size = parts and tonumber(parts[2], 16) or 0
            local type = parts[4]
            if type == "\"linux\"" or type == "\"firmware\"" then
                if size > whole_size then
                    whole_size = size
                end
            elseif type == "\"kernel\"" or type == "\"kernel0\"" then
                kern_size = size
            elseif type == "\"rootfs\"" or type == "\"rootfs0\"" or type == "\"ubi\"" or type == "\"ubi0\"" then
                root_size = size
            end
        end
    end

    if whole_size > 0 then
        return whole_size
    elseif kern_size > 0 and root_size > kern_size then
        return kern_size + root_size
    end
    return whole_size
end

local function found_image(file_s)
    local attr = lfs.attributes(file_s.path_dir .. file_s.file_name)
    local res = "not found"
    if attr ~= nil then
        if attr.mode == "file" then
            trf.image.size = tonumber(attr.size)
            res = "found"
        end
    end
    return res
end

function restore_module.validateImage(file_s)
    local is_too_big = false
    local image_ifFound = found_image(file_s)
    if image_ifFound == "found" then
        io.write("info: Image validation ......................  ")
        local storage_size = findStorageSize()
        is_too_big = (storage_size > 0 and trf.image.size > storage_size)
        if is_too_big then
            return "image too big"
        end
    else
        print("error: image " .. image_ifFound)
        return image_ifFound
    end

    local attr = lfs.attributes("/tmp/sysupgrade.meta")
    if attr ~= nil then
        if attr.mode == "file" then
            local rm_cmd = "rm /tmp/sysupgrade.meta 2>/dev/null"
            local rm_res = os.execute(rm_cmd)
            if rm_res ~= 0 then
                print("error: can not delete old sysupgrade meta file")
            end
        end
    end

    local cmd_validate = "ubus call system validate_firmware_image '{\"path\":\"" .. file_s.path_dir .. file_s.file_name .. "\"}'"
    local validateJson = tf.collectJsonTable(cmd_validate)
    local valid = false
    local device_match = false
    local valid_res = "not valid"
    if validateJson ~= nil then
        if validateJson["tests"] ~= nil then
            local fwtool_device_match = validateJson["tests"]
            device_match = fwtool_device_match["fwtool_device_match"]
        else
            print("error: validateJson test is empty")
        end
        if validateJson["valid"] ~= nil then
            valid = validateJson["valid"]
            trf.image.allow_backup = validateJson["allow_backup"]
        else
            print("error: validateJson test is empty")
        end
        if device_match and valid then
            trf.image.valid = true
            valid_res = "valid"
        else
            valid_res = "not valid"
        end
        if valid_res ~= "valid" then
            local cmd_delete = "rm " .. file_s.path_dir .. file_s.file_name .. " 2>/dev/null "
            valid_res = os.execute(cmd_delete)
            if valid_res ~= 0 then
                print("error: can not delete not valid firmware image")
            end
        elseif valid_res == "valid" then
            print(valid_res)
            -- user handler
        end
        return valid_res
    else
        print("critical: validate Json is empty")
    end
end

function restore_module.firmware_show()
    local fileList = {}
    if trf.transfer_param["local_file"] ~= nil then
        local local_file_s = trf.transfer_param["local_file"]
        if local_file_s["firmware"] ~= nil then
            local_file_s = local_file_s["firmware"]
        end

        fileList = trf.get_fileList(local_file_s.path_dir)
        if fileList ~= nil then
            print("Firmware images:")
            for _, f_struct in pairs(fileList) do
                if f_struct.name ~= local_file_s.file_name then
                    print("error: image file name is wrong")
                else
                    print("\tfile name:         " .. f_struct.name)

                    local cmd_meta_image = "cat /tmp/sysupgrade.meta"
                    local meta_image_json = tf.collectJsonTable(cmd_meta_image)
                    if meta_image_json ~= nil and meta_image_json["version"] ~= nil then
                        meta_image_json = meta_image_json["version"]
                        print("\tcompany:           " .. meta_image_json["dist"])
                        print("\tversion:           " .. meta_image_json["version"])
                        print("\tboard:             " .. meta_image_json["board"])
                    end
                    print("\tfile size:         " .. f_struct.size .. " byte")
                    print("\tchecksum md5:      " .. trf.get_image_md5("firmware"))
                end
            end
        else
            print("warning: firmware image not found")
        end
    else
        print("critical: transfer file module not presented")
    end
end

function restore_module.firmware_install()
    local options = "-n "
    local auto = true
    local host = ""
    local remote_file = ""
    local download_enable = true
    local install_enable = false
    local res = ""

    local err = "error"
    local local_file_s = {}
    if trf.transfer_param["local_file"] ~= nil then
        local_file_s = trf.transfer_param["local_file"]
        if trf.transfer_param["local_file"] ~= nil then
            local_file_s = local_file_s["firmware"]
            err = "no_error"
        end
    end
    if err == "error" then
        print("critical: transfer module is wrong")
        return "error: transfer module is wrong"
    end
    local arg_list = {}
    arg_list = parsingArg()
    if arg_list == nil then
        print("critical: arg list is empty")
        return
    end
    if arg_list["auto"] ~= nil and arg_list["auto"] == "yes" then
        auto = false
        download_enable = true
        install_enable = true
    end

    if arg_list["remote_file"] ~= nil then
        remote_file = arg_list["remote_file"]
        if arg_list["host"] ~= nil then
            host = arg_list["host"]
            download_enable = true
            print("info: update will be installed from download image")
        else
            print("critical: no remote host")
        end
    elseif arg_list["remote_file"] == nil and arg_list["host"] == nil then
        download_enable = false
        print("info: update wil be installed from local image")
    end

    local copy_res = ""
    local valid_res = ""
    if download_enable then
        res = trf.tftp_transfer("get", local_file_s.file_name, remote_file, host, local_file_s)
        if res == "successful" then
            copy_res = trf.post_copy_file(local_file_s, "mv")
        end
    else
        copy_res = "copy_ok"
    end

    if copy_res == "copy_ok" then
        valid_res = restore_module.validateImage(local_file_s)
        if valid_res ~= "valid" then
            return
        elseif valid_res == "valid" then
            if arg_list["auto"] == nil or arg_list["auto"] == "no" then
                print("Do you really want to update? (yes / no)")
                local s = io.read(3)
                if s == "yes" then
                    install_enable = true
                elseif s == "no\n" or s == "no " then
                    print("info: update process canceled by user")
                    return
                else
                    print("\"yes\" or \"no\" only")
                end
            elseif arg_list["auto"] ~= nil and arg_list["auto"] == "yes" then
                install_enable = true
            end
        end
    end

    if install_enable then
        if arg_list["keep_setting"] ~= nil and arg_list["keep_setting"] == "yes" and trf.image.allow_backup then
            options = " "
        end
        local cmd_sysupgrade = "sysupgrade " .. options .. " " .. local_file_s.path_dir .. local_file_s.file_name
        print("info: The system is flashing now....... \nDO NOT POWER OFF THE DEVICE !!! \nReconnect manually after a few minutes")
        print("It might be necessary to renew the address of your computer to reach the device again, depending on your settings.")
        res = os.execute(cmd_sysupgrade)
        if res ~= 0 then
            print("critical: can not update the system")
        end
    end
end

function restore_module.backup_show(file_s)
    local fileList = trf.get_fileList(file_s.path_dir)

    if fileList == nil then
        print("info: backup not found")
        return
    end

    for num, entries in pairs(fileList) do
        print("\t>>> " .. num)
        if entries["type"] ~= nil and entries["type"] == "file" then
            if entries["name"] ~= nil then
                print("\t\tname = \t" .. entries["name"])
            end
            if entries["size"] ~= nil then
                print("\t\tsize = \t" .. entries["size"] .. " byte")
            end
        end
    end
end

local function backup_apply(file_s)
    local attr = lfs.attributes(file_s.path_dir .. file_s.file_name)
    if attr ~= nil and attr.mode == "file" then
        local cmd_rename = "mv " .. file_s.path_dir .. file_s.file_name .. " " .. file_s.path_dir .. file_s.file_name .. ".tar.gz.cpt"
        --print("cmd_rename = " .. cmd_rename)
        local res = os.execute(cmd_rename)
        if res ~= 0 then
            print("error: can not rename backup file")
            return 1
        end

        local cmd_crypt = "ccrypt -d -K 123 " .. file_s.path_dir .. file_s.file_name .. ".tar.gz.cpt" .. " 2>/dev/null"
        res = os.execute(cmd_crypt)
        if res ~= 0 then
            print("error: backup file is wrong")
            return 1
        end

        local backup_install_dir = "/etc/tf_backup"
        attr = lfs.attributes(backup_install_dir)
        if attr == nil then
            os.execute("mkdir " .. backup_install_dir .. " 2>/dev/null")
        end
        local cmd_tar = "tar -C " .. backup_install_dir .. " -xzf " .. file_s.path_dir .. file_s.file_name .. ".tar.gz" .. " 2>/dev/null"
        res = os.execute(cmd_tar)
        if res ~= 0 then
            print("error: backup file is wrong")
            return 1
        end
        print("info: backup restored successfully")
    else
        print("error: backup file not found")
        return 1
    end
    return 0
end

local function macset()
    local attr = lfs.attributes("/usr/bin/macset.sh")
    if attr == nil then
        print("error: can not set MAC address")
        return
    end
    local cmd_macset = "/usr/bin/macset.sh" .. " 2>/dev/null"
    local res = os.execute(cmd_macset)
    return res
end

function restore_module.backup_apply_handler(file_s)
    local apply_res = backup_apply(file_s)
    local attr = lfs.attributes(file_s.path_dir)
    if attr ~= nil then
        local cmd_rm = "rm -r " .. file_s.path_dir .. " 2>/dev/null"
        local res = os.execute(cmd_rm)
        if res ~= 0 then
            print("error: can not delete backup file")
            return
        end
    end
    local res = 1
    if apply_res == 0 then
        res = macset()
    end
    if res == 0 then
        print("info: Switch will be rebooted............. Reconnect manually after a few minutes")
        if os.execute("reboot") ~= 0 then
            print("error: reboot command is wrong. Do reboot in manual mode")
        end
    end
end

function restore_module.backup_generate(file_s)
    local res = bk.checkChanges()
    if res ~= 0 then
        return res
    end
    res = bk.createTar_archive(file_s)
    return res
end

function restore_module.restore_default()
    if arg[3] ~= nil then
        local permit = false
        local cmd_default = "/sbin/firstboot -r -y " .. " 2>/dev/null"
        if arg[3] == "yes" then
            permit = true
        elseif arg[3] == "no" then
            print("Do you really want to erase all settings and restore factory settings? (yes / no)")
            local s = io.read(3)
            if s == "yes" then
                permit = true
            elseif s == "no\n" or s == "no " then
                print("info: restore factory settings canceled by user")
                return
            else
                print("\"yes\" or \"no\" only")
            end
        end
        if permit then
            print("info: Rebooting ..............")
            print("info: The system is rebooting now. If the restored configuration changed the current LAN IP address, you might need to reconnect manually")
            --print("os.execute(cmd) = " .. cmd_default)
            os.execute(cmd_default)
        end
    end
end

function restore_module.restore_recovery()
    print("restore_recovery")
    if arg[3] ~= nil then
        local permit = false
        local cmd_recovery = "/sbin/recoveryboot" .. " 2>/dev/null"
        if arg[3] == "yes" then
            permit = true
        elseif arg[3] == "no" then
            print("Do you really want to reboot to Recovery? (yes / no)")
            local s = io.read(3)
            if s == "yes" then
                permit = true
            elseif s == "no\n" or s == "no " then
                print("info: reboot to recovery canceled by user")
                return
            else
                print("\"yes\" or \"no\" only")
            end
        end
        if permit then
            print("info: Rebooting ..............")
            print("The system is currently booting into recovery mode with default settings. Access is only possible at http://192.168.0.1 on web only")
            --print("os.execute(cmd) = " .. cmd_recovery)
            os.execute(cmd_recovery)
        end
    end
end

return restore_module

